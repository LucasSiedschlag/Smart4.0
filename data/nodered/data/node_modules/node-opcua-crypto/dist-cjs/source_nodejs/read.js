"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readPublicRsaKey = exports.readPrivateRsaKey = exports.setCertificateStore = exports.readPrivateKeyPEM = exports.readPublicKeyPEM = exports.readCertificatePEM = exports.readPrivateKey = exports.makePrivateKeyThumbPrint = exports.readPublicKey = exports.readCertificate = void 0;
var assert_1 = __importDefault(require("assert"));
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var crypto_1 = require("crypto");
var crypto_utils_js_1 = require("../source/crypto_utils.js");
var sshpk = require("sshpk");
function _readPemFile(filename) {
    (0, assert_1.default)(typeof filename === "string");
    return (0, crypto_utils_js_1.removeTrailingLF)(fs_1.default.readFileSync(filename, "utf-8"));
}
function _readPemOrDerFileAsDER(filename) {
    if (filename.match(/.*\.der/)) {
        return fs_1.default.readFileSync(filename);
    }
    var raw_key = _readPemFile(filename);
    return (0, crypto_utils_js_1.convertPEMtoDER)(raw_key);
}
function readCertificate(filename) {
    return _readPemOrDerFileAsDER(filename);
}
exports.readCertificate = readCertificate;
function readPublicKey(filename) {
    if (filename.match(/.*\.der/)) {
        var der = fs_1.default.readFileSync(filename);
        return (0, crypto_1.createPublicKey)(der);
    }
    else {
        var raw_key = _readPemFile(filename);
        return (0, crypto_1.createPublicKey)(raw_key);
    }
}
exports.readPublicKey = readPublicKey;
function myCreatePrivateKey(rawKey) {
    if (!crypto_1.createPrivateKey || process.env.NO_CREATE_PRIVATEKEY) {
        if (rawKey instanceof Buffer) {
            var pemKey = (0, crypto_utils_js_1.toPem)(rawKey, "PRIVATE KEY");
            (0, assert_1.default)(["RSA PRIVATE KEY", "PRIVATE KEY"].indexOf((0, crypto_utils_js_1.identifyPemType)(pemKey)) >= 0);
            return { hidden: pemKey };
        }
        return { hidden: ensureTrailingLF(rawKey) };
    }
    var backup = process.env.OPENSSL_CONF;
    process.env.OPENSSL_CONF = "/dev/null";
    var retValue = (0, crypto_1.createPrivateKey)(rawKey);
    process.env.OPENSSL_CONF = backup;
    return { hidden: retValue };
}
function makePrivateKeyThumbPrint(privateKey) {
    return Buffer.alloc(0);
}
exports.makePrivateKeyThumbPrint = makePrivateKeyThumbPrint;
function ensureTrailingLF(str) {
    return str.match(/\n$/) ? str : str + "\n";
}
function readPrivateKey(filename) {
    if (filename.match(/.*\.der/)) {
        var der = fs_1.default.readFileSync(filename);
        return myCreatePrivateKey(der);
    }
    else {
        var raw_key = _readPemFile(filename);
        return myCreatePrivateKey(raw_key);
    }
}
exports.readPrivateKey = readPrivateKey;
function readCertificatePEM(filename) {
    return _readPemFile(filename);
}
exports.readCertificatePEM = readCertificatePEM;
function readPublicKeyPEM(filename) {
    return _readPemFile(filename);
}
exports.readPublicKeyPEM = readPublicKeyPEM;
function readPrivateKeyPEM(filename) {
    return _readPemFile(filename);
}
exports.readPrivateKeyPEM = readPrivateKeyPEM;
var __certificate_store = path_1.default.join(__dirname, "../../certificates/");
function setCertificateStore(store) {
    var old_store = __certificate_store;
    __certificate_store = store;
    return old_store;
}
exports.setCertificateStore = setCertificateStore;
function readPrivateRsaKey(filename) {
    if (!crypto_1.createPrivateKey) {
        throw new Error("createPrivateKey is not supported in this environment");
    }
    if (filename.substring(0, 1) !== "." && !fs_1.default.existsSync(filename)) {
        filename = __certificate_store + filename;
    }
    var content = fs_1.default.readFileSync(filename, "utf8");
    var sshKey = sshpk.parsePrivateKey(content, "auto");
    var key = sshKey.toString("pkcs1");
    var hidden = (0, crypto_1.createPrivateKey)({ format: "pem", type: "pkcs1", key: key });
    return { hidden: hidden };
}
exports.readPrivateRsaKey = readPrivateRsaKey;
function readPublicRsaKey(filename) {
    if (filename.substring(0, 1) !== "." && !fs_1.default.existsSync(filename)) {
        filename = __certificate_store + filename;
    }
    var content = fs_1.default.readFileSync(filename, "utf-8");
    var sshKey = sshpk.parseKey(content, "ssh");
    var key = sshKey.toString("pkcs1");
    return (0, crypto_1.createPublicKey)({ format: "pem", type: "pkcs1", key: key });
}
exports.readPublicRsaKey = readPublicRsaKey;
//# sourceMappingURL=read.js.map