"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exploreCertificateInfo = exports.coerceCertificate = void 0;
var assert_1 = __importDefault(require("assert"));
var crypto_explore_certificate_js_1 = require("./crypto_explore_certificate.js");
var crypto_utils_js_1 = require("./crypto_utils.js");
function coerceCertificate(certificate) {
    if (typeof certificate === "string") {
        certificate = (0, crypto_utils_js_1.convertPEMtoDER)(certificate);
    }
    (0, assert_1.default)(certificate instanceof Buffer);
    return certificate;
}
exports.coerceCertificate = coerceCertificate;
function exploreCertificateInfo(certificate) {
    certificate = coerceCertificate(certificate);
    var certInfo = (0, crypto_explore_certificate_js_1.exploreCertificate)(certificate);
    var data = {
        publicKeyLength: certInfo.tbsCertificate.subjectPublicKeyInfo.keyLength,
        notBefore: certInfo.tbsCertificate.validity.notBefore,
        notAfter: certInfo.tbsCertificate.validity.notAfter,
        publicKey: certInfo.tbsCertificate.subjectPublicKeyInfo.subjectPublicKey,
        subject: certInfo.tbsCertificate.subject,
    };
    if (!(data.publicKeyLength === 512 ||
        data.publicKeyLength === 384 ||
        data.publicKeyLength === 256 ||
        data.publicKeyLength === 128)) {
        throw new Error("Invalid public key length (expecting 128,256,384 or 512)" + data.publicKeyLength);
    }
    return data;
}
exports.exploreCertificateInfo = exploreCertificateInfo;
//# sourceMappingURL=explore_certificate.js.map