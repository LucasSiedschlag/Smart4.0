"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyChunkSignatureWithDerivedKeys = exports.makeMessageChunkSignatureWithDerivedKeys = exports.decryptBufferWithDerivedKeys = exports.encryptBufferWithDerivedKeys = exports.computePaddingFooter = exports.verifyChunkSignature = exports.removePadding = exports.reduceLength = exports.computeDerivedKeys = exports.makePseudoRandomBuffer = void 0;
var assert_1 = __importDefault(require("assert"));
var crypto_1 = require("crypto");
var buffer_utils_js_1 = require("./buffer_utils.js");
var crypto_utils_js_1 = require("./crypto_utils.js");
var explore_certificate_js_1 = require("./explore_certificate.js");
function HMAC_HASH(sha1or256, secret, message) {
    return (0, crypto_1.createHmac)(sha1or256, secret).update(message).digest();
}
function plus(buf1, buf2) {
    return Buffer.concat([buf1, buf2]);
}
function makePseudoRandomBuffer(secret, seed, minLength, sha1or256) {
    (0, assert_1.default)(seed instanceof Buffer);
    (0, assert_1.default)(sha1or256 === "SHA1" || sha1or256 === "SHA256");
    var a = [];
    a[0] = seed;
    var index = 1;
    var p_hash = (0, buffer_utils_js_1.createFastUninitializedBuffer)(0);
    while (p_hash.length <= minLength) {
        a[index] = HMAC_HASH(sha1or256, secret, a[index - 1]);
        p_hash = plus(p_hash, HMAC_HASH(sha1or256, secret, plus(a[index], seed)));
        index += 1;
    }
    return p_hash.subarray(0, minLength);
}
exports.makePseudoRandomBuffer = makePseudoRandomBuffer;
function computeDerivedKeys(secret, seed, options) {
    (0, assert_1.default)(Number.isFinite(options.signatureLength));
    (0, assert_1.default)(Number.isFinite(options.encryptingKeyLength));
    (0, assert_1.default)(Number.isFinite(options.encryptingBlockSize));
    (0, assert_1.default)(typeof options.algorithm === "string");
    options.sha1or256 = options.sha1or256 || "SHA1";
    (0, assert_1.default)(typeof options.sha1or256 === "string");
    var offset1 = options.signingKeyLength;
    var offset2 = offset1 + options.encryptingKeyLength;
    var minLength = offset2 + options.encryptingBlockSize;
    var buf = makePseudoRandomBuffer(secret, seed, minLength, options.sha1or256);
    return {
        signatureLength: options.signatureLength,
        signingKeyLength: options.signingKeyLength,
        encryptingKeyLength: options.encryptingKeyLength,
        encryptingBlockSize: options.encryptingBlockSize,
        algorithm: options.algorithm,
        sha1or256: options.sha1or256,
        signingKey: buf.subarray(0, offset1),
        encryptingKey: buf.subarray(offset1, offset2),
        initializationVector: buf.subarray(offset2, minLength),
    };
}
exports.computeDerivedKeys = computeDerivedKeys;
function reduceLength(buffer, byteToRemove) {
    return buffer.subarray(0, buffer.length - byteToRemove);
}
exports.reduceLength = reduceLength;
function removePadding(buffer) {
    var nbPaddingBytes = buffer.readUInt8(buffer.length - 1) + 1;
    return reduceLength(buffer, nbPaddingBytes);
}
exports.removePadding = removePadding;
function verifyChunkSignature(chunk, options) {
    (0, assert_1.default)(chunk instanceof Buffer);
    var signatureLength = options.signatureLength || 0;
    if (signatureLength === 0) {
        var cert = (0, explore_certificate_js_1.exploreCertificateInfo)(options.publicKey);
        signatureLength = cert.publicKeyLength || 0;
    }
    var block_to_verify = chunk.subarray(0, chunk.length - signatureLength);
    var signature = chunk.subarray(chunk.length - signatureLength);
    return (0, crypto_utils_js_1.verifyMessageChunkSignature)(block_to_verify, signature, options);
}
exports.verifyChunkSignature = verifyChunkSignature;
function computePaddingFooter(buffer, derivedKeys) {
    (0, assert_1.default)(Object.prototype.hasOwnProperty.call(derivedKeys, "encryptingBlockSize"));
    var paddingSize = derivedKeys.encryptingBlockSize - ((buffer.length + 1) % derivedKeys.encryptingBlockSize);
    var padding = (0, buffer_utils_js_1.createFastUninitializedBuffer)(paddingSize + 1);
    padding.fill(paddingSize);
    return padding;
}
exports.computePaddingFooter = computePaddingFooter;
function derivedKeys_algorithm(derivedKeys) {
    (0, assert_1.default)(Object.prototype.hasOwnProperty.call(derivedKeys, "algorithm"));
    var algorithm = derivedKeys.algorithm || "aes-128-cbc";
    (0, assert_1.default)(algorithm === "aes-128-cbc" || algorithm === "aes-256-cbc");
    return algorithm;
}
function encryptBufferWithDerivedKeys(buffer, derivedKeys) {
    var algorithm = derivedKeys_algorithm(derivedKeys);
    var key = derivedKeys.encryptingKey;
    var initVector = derivedKeys.initializationVector;
    var cipher = (0, crypto_1.createCipheriv)(algorithm, key, initVector);
    cipher.setAutoPadding(false);
    var encrypted_chunks = [];
    encrypted_chunks.push(cipher.update(buffer));
    encrypted_chunks.push(cipher.final());
    return Buffer.concat(encrypted_chunks);
}
exports.encryptBufferWithDerivedKeys = encryptBufferWithDerivedKeys;
function decryptBufferWithDerivedKeys(buffer, derivedKeys) {
    var algorithm = derivedKeys_algorithm(derivedKeys);
    var key = derivedKeys.encryptingKey;
    var initVector = derivedKeys.initializationVector;
    var cipher = (0, crypto_1.createDecipheriv)(algorithm, key, initVector);
    cipher.setAutoPadding(false);
    var decrypted_chunks = [];
    decrypted_chunks.push(cipher.update(buffer));
    decrypted_chunks.push(cipher.final());
    return Buffer.concat(decrypted_chunks);
}
exports.decryptBufferWithDerivedKeys = decryptBufferWithDerivedKeys;
function makeMessageChunkSignatureWithDerivedKeys(message, derivedKeys) {
    (0, assert_1.default)(message instanceof Buffer);
    (0, assert_1.default)(derivedKeys.signingKey instanceof Buffer);
    (0, assert_1.default)(typeof derivedKeys.sha1or256 === "string");
    (0, assert_1.default)(derivedKeys.sha1or256 === "SHA1" || derivedKeys.sha1or256 === "SHA256");
    var signature = (0, crypto_1.createHmac)(derivedKeys.sha1or256, derivedKeys.signingKey).update(message).digest();
    (0, assert_1.default)(signature.length === derivedKeys.signatureLength);
    return signature;
}
exports.makeMessageChunkSignatureWithDerivedKeys = makeMessageChunkSignatureWithDerivedKeys;
function verifyChunkSignatureWithDerivedKeys(chunk, derivedKeys) {
    var message = chunk.subarray(0, chunk.length - derivedKeys.signatureLength);
    var expectedSignature = chunk.subarray(chunk.length - derivedKeys.signatureLength);
    var computedSignature = makeMessageChunkSignatureWithDerivedKeys(message, derivedKeys);
    return computedSignature.toString("hex") === expectedSignature.toString("hex");
}
exports.verifyChunkSignatureWithDerivedKeys = verifyChunkSignatureWithDerivedKeys;
//# sourceMappingURL=derived_keys.js.map