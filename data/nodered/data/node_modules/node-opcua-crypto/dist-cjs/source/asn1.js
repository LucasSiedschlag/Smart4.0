"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._readTime = exports._findBlockAtIndex = exports._readDirectoryName = exports.compactDirectoryName = exports._readValue = exports._readVersionValue = exports._readBooleanValue = exports._readIntegerValue = exports._readLongIntegerValue = exports._readSignatureValue = exports._readSignatureValueBin = exports._readECCAlgorithmIdentifier = exports._readAlgorithmIdentifier = exports._readObjectIdentifier = exports._readListOfInteger = exports._readIntegerAsByteString = exports._getBlock = exports._readOctetString = exports.formatBuffer2DigitHexWithColum = exports._readBitString = exports.parseBitString = exports._readStruct = exports.readTag = exports.TagType = void 0;
var assert_1 = __importDefault(require("assert"));
var oid_map_js_1 = require("./oid_map.js");
var TagType;
(function (TagType) {
    TagType[TagType["BOOLEAN"] = 1] = "BOOLEAN";
    TagType[TagType["INTEGER"] = 2] = "INTEGER";
    TagType[TagType["BIT_STRING"] = 3] = "BIT_STRING";
    TagType[TagType["OCTET_STRING"] = 4] = "OCTET_STRING";
    TagType[TagType["NULL"] = 5] = "NULL";
    TagType[TagType["OBJECT_IDENTIFIER"] = 6] = "OBJECT_IDENTIFIER";
    TagType[TagType["UTF8String"] = 12] = "UTF8String";
    TagType[TagType["NumericString"] = 18] = "NumericString";
    TagType[TagType["PrintableString"] = 19] = "PrintableString";
    TagType[TagType["TeletexString"] = 20] = "TeletexString";
    TagType[TagType["IA5String"] = 22] = "IA5String";
    TagType[TagType["UTCTime"] = 23] = "UTCTime";
    TagType[TagType["GeneralizedTime"] = 24] = "GeneralizedTime";
    TagType[TagType["GraphicString"] = 25] = "GraphicString";
    TagType[TagType["VisibleString"] = 26] = "VisibleString";
    TagType[TagType["GeneralString"] = 27] = "GeneralString";
    TagType[TagType["UniversalString"] = 28] = "UniversalString";
    TagType[TagType["BMPString"] = 30] = "BMPString";
    TagType[TagType["SEQUENCE"] = 48] = "SEQUENCE";
    TagType[TagType["SET"] = 49] = "SET";
    TagType[TagType["A3"] = 163] = "A3";
})(TagType || (exports.TagType = TagType = {}));
function readTag(buf, pos) {
    (0, assert_1.default)(buf instanceof Buffer);
    (0, assert_1.default)(Number.isFinite(pos) && pos >= 0);
    if (buf.length <= pos) {
        throw new Error("Invalid position : buf.length=" + buf.length + " pos =" + pos);
    }
    var tag = buf.readUInt8(pos);
    pos += 1;
    var length = buf.readUInt8(pos);
    pos += 1;
    if (length > 127) {
        var nbBytes = length & 0x7f;
        length = 0;
        for (var i = 0; i < nbBytes; i++) {
            length = length * 256 + buf.readUInt8(pos);
            pos += 1;
        }
    }
    return { tag: tag, position: pos, length: length };
}
exports.readTag = readTag;
function _readStruct(buf, blockInfo) {
    var length = blockInfo.length;
    var cursor = blockInfo.position;
    var end = blockInfo.position + length;
    var blocks = [];
    while (cursor < end) {
        var inner = readTag(buf, cursor);
        cursor = inner.position + inner.length;
        blocks.push(inner);
    }
    return blocks;
}
exports._readStruct = _readStruct;
function parseBitString(buffer, start, end, maxLength) {
    var unusedBit = buffer.readUInt8(start), lenBit = ((end - start - 1) << 3) - unusedBit, intro = "(" + lenBit + " bit)\n";
    var s = "", skip = unusedBit;
    for (var i = end - 1; i > start; --i) {
        var b = buffer.readUInt8(i);
        for (var j = skip; j < 8; ++j) {
            s += (b >> j) & 1 ? "1" : "0";
        }
        skip = 0;
        (0, assert_1.default)(s.length <= maxLength);
    }
    return intro + s;
}
exports.parseBitString = parseBitString;
function _readBitString(buffer, block) {
    (0, assert_1.default)(block.tag === TagType.BIT_STRING);
    var data = _getBlock(buffer, block);
    var ignore_bits = data.readUInt8(0);
    return {
        lengthInBits: data.length * 8 - ignore_bits,
        lengthInBytes: data.length - 1,
        data: data.subarray(1),
        debug: parseBitString(buffer, block.position, block.length + block.position, 4 * 16 * 1024),
    };
}
exports._readBitString = _readBitString;
function formatBuffer2DigitHexWithColum(buffer) {
    var value = [];
    for (var i = 0; i < buffer.length; i++) {
        value.push(("00" + buffer.readUInt8(i).toString(16)).substr(-2, 2));
    }
    return value
        .join(":")
        .toUpperCase()
        .replace(/^(00:)*/, "");
}
exports.formatBuffer2DigitHexWithColum = formatBuffer2DigitHexWithColum;
function _readOctetString(buffer, block) {
    (0, assert_1.default)(block.tag === TagType.OCTET_STRING);
    var tag = readTag(buffer, block.position);
    (0, assert_1.default)(tag.tag === TagType.OCTET_STRING);
    var nbBytes = tag.length;
    var pos = tag.position;
    var b = buffer.subarray(pos, pos + nbBytes);
    return b;
}
exports._readOctetString = _readOctetString;
function _getBlock(buffer, block) {
    var start = block.position;
    var end = block.position + block.length;
    return buffer.subarray(start, end);
}
exports._getBlock = _getBlock;
function _readIntegerAsByteString(buffer, block) {
    return _getBlock(buffer, block);
}
exports._readIntegerAsByteString = _readIntegerAsByteString;
function _readListOfInteger(buffer) {
    var block = readTag(buffer, 0);
    var inner_blocks = _readStruct(buffer, block);
    return inner_blocks.map(function (bblock) {
        return _readIntegerAsByteString(buffer, bblock);
    });
}
exports._readListOfInteger = _readListOfInteger;
function parseOID(buffer, start, end) {
    var s = "", n = 0, bits = 0;
    for (var i = start; i < end; ++i) {
        var v = buffer.readUInt8(i);
        n = n * 128 + (v & 0x7f);
        bits += 7;
        if (!(v & 0x80)) {
            if (s === "") {
                var m = n < 80 ? (n < 40 ? 0 : 1) : 2;
                s = m + "." + (n - m * 40);
            }
            else {
                s += "." + n.toString();
            }
            n = 0;
            bits = 0;
        }
    }
    (0, assert_1.default)(bits === 0);
    return s;
}
function _readObjectIdentifier(buffer, block) {
    (0, assert_1.default)(block.tag === TagType.OBJECT_IDENTIFIER);
    var b = buffer.subarray(block.position, block.position + block.length);
    var oid = parseOID(b, 0, block.length);
    return {
        oid: oid,
        name: oid_map_js_1.oid_map[oid] ? oid_map_js_1.oid_map[oid].d : oid,
    };
}
exports._readObjectIdentifier = _readObjectIdentifier;
function _readAlgorithmIdentifier(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    return {
        identifier: _readObjectIdentifier(buffer, inner_blocks[0]).name,
    };
}
exports._readAlgorithmIdentifier = _readAlgorithmIdentifier;
;
function _readECCAlgorithmIdentifier(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    return {
        identifier: _readObjectIdentifier(buffer, inner_blocks[1]).name,
    };
}
exports._readECCAlgorithmIdentifier = _readECCAlgorithmIdentifier;
;
function _readSignatureValueBin(buffer, block) {
    return _readBitString(buffer, block).data;
}
exports._readSignatureValueBin = _readSignatureValueBin;
function _readSignatureValue(buffer, block) {
    return _readSignatureValueBin(buffer, block).toString("hex");
}
exports._readSignatureValue = _readSignatureValue;
function _readLongIntegerValue(buffer, block) {
    (0, assert_1.default)(block.tag === TagType.INTEGER, "expecting a INTEGER tag");
    var pos = block.position;
    var nbBytes = block.length;
    var buf = buffer.subarray(pos, pos + nbBytes);
    return buf;
}
exports._readLongIntegerValue = _readLongIntegerValue;
function _readIntegerValue(buffer, block) {
    (0, assert_1.default)(block.tag === TagType.INTEGER, "expecting a INTEGER tag");
    var pos = block.position;
    var nbBytes = block.length;
    (0, assert_1.default)(nbBytes < 4);
    var value = 0;
    for (var i = 0; i < nbBytes; i++) {
        value = value * 256 + buffer.readUInt8(pos);
        pos += 1;
    }
    return value;
}
exports._readIntegerValue = _readIntegerValue;
function _readBooleanValue(buffer, block) {
    (0, assert_1.default)(block.tag === TagType.BOOLEAN, "expecting a BOOLEAN tag. got " + TagType[block.tag]);
    var pos = block.position;
    var nbBytes = block.length;
    (0, assert_1.default)(nbBytes < 4);
    var value = buffer.readUInt8(pos) ? true : false;
    return value;
}
exports._readBooleanValue = _readBooleanValue;
function _readVersionValue(buffer, block) {
    block = readTag(buffer, block.position);
    return _readIntegerValue(buffer, block);
}
exports._readVersionValue = _readVersionValue;
function convertGeneralizedTime(str) {
    var year = parseInt(str.substr(0, 4), 10);
    var month = parseInt(str.substr(4, 2), 10) - 1;
    var day = parseInt(str.substr(6, 2), 10);
    var hours = parseInt(str.substr(8, 2), 10);
    var mins = parseInt(str.substr(10, 2), 10);
    var secs = parseInt(str.substr(12, 2), 10);
    return new Date(Date.UTC(year, month, day, hours, mins, secs));
}
function _readBMPString(buffer, block) {
    var strBuff = _getBlock(buffer, block);
    var str = "";
    for (var i = 0; i < strBuff.length; i += 2) {
        var word = strBuff.readUInt16BE(i);
        str += String.fromCharCode(word);
    }
    return str;
}
function convertUTCTime(str) {
    var year = parseInt(str.substr(0, 2), 10);
    var month = parseInt(str.substr(2, 2), 10) - 1;
    var day = parseInt(str.substr(4, 2), 10);
    var hours = parseInt(str.substr(6, 2), 10);
    var mins = parseInt(str.substr(8, 2), 10);
    var secs = parseInt(str.substr(10, 2), 10);
    year += year >= 50 ? 1900 : 2000;
    return new Date(Date.UTC(year, month, day, hours, mins, secs));
}
function _readValue(buffer, block) {
    switch (block.tag) {
        case TagType.BOOLEAN:
            return _readBooleanValue(buffer, block);
        case TagType.BMPString:
            return _readBMPString(buffer, block);
        case TagType.PrintableString:
        case TagType.TeletexString:
        case TagType.UTF8String:
        case TagType.NumericString:
        case TagType.IA5String:
            return _getBlock(buffer, block).toString("ascii");
        case TagType.UTCTime:
            return convertUTCTime(_getBlock(buffer, block).toString("ascii"));
        case TagType.GeneralizedTime:
            return convertGeneralizedTime(_getBlock(buffer, block).toString("ascii"));
        default:
            throw new Error("Invalid tag 0x" + block.tag.toString(16) + "");
    }
}
exports._readValue = _readValue;
function compactDirectoryName(d) {
    return JSON.stringify(d);
}
exports.compactDirectoryName = compactDirectoryName;
function _readDirectoryName(buffer, block) {
    var set_blocks = _readStruct(buffer, block);
    var names = {};
    for (var _i = 0, set_blocks_1 = set_blocks; _i < set_blocks_1.length; _i++) {
        var set_block = set_blocks_1[_i];
        (0, assert_1.default)(set_block.tag === 0x31);
        var blocks = _readStruct(buffer, set_block);
        (0, assert_1.default)(blocks.length === 1);
        (0, assert_1.default)(blocks[0].tag === 0x30);
        var sequenceBlock = _readStruct(buffer, blocks[0]);
        (0, assert_1.default)(sequenceBlock.length === 2);
        var type = _readObjectIdentifier(buffer, sequenceBlock[0]);
        names[type.name] = _readValue(buffer, sequenceBlock[1]);
    }
    return names;
}
exports._readDirectoryName = _readDirectoryName;
function _findBlockAtIndex(blocks, index) {
    var tmp = blocks.filter(function (b) { return b.tag === 0xa0 + index || b.tag === 0x80 + index; });
    if (tmp.length === 0) {
        return null;
    }
    return tmp[0];
}
exports._findBlockAtIndex = _findBlockAtIndex;
function _readTime(buffer, block) {
    return _readValue(buffer, block);
}
exports._readTime = _readTime;
//# sourceMappingURL=asn1.js.map