"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPublicKeyFromCertificate = exports.extractPublicKeyFromCertificateSync = exports.coerceCertificatePem = exports.privateDecrypt_long = exports.publicEncrypt_long = exports.privateDecrypt = exports.publicEncrypt = exports.privateDecrypt_native = exports.publicEncrypt_native = exports.PaddingAlgorithm = exports.RSA_PKCS1_PADDING = exports.RSA_PKCS1_OAEP_PADDING = exports.makeSHA1Thumbprint = exports.verifyMessageChunkSignature = exports.makeMessageChunkSignature = exports.hexDump = exports.convertPEMtoDER = exports.toPem = exports.removeTrailingLF = exports.identifyPemType = void 0;
var constants_1 = __importDefault(require("constants"));
var assert_1 = __importDefault(require("assert"));
var crypto_1 = require("crypto");
var hexy = require("hexy").hexy;
var buffer_utils_js_1 = require("./buffer_utils.js");
var crypto_explore_certificate_js_1 = require("./crypto_explore_certificate.js");
var jsrsasign = require("jsrsasign");
var PEM_REGEX = /^(-----BEGIN (.*)-----\r?\n([/+=a-zA-Z0-9\r\n]*)\r?\n-----END \2-----\r?\n?)/gm;
var PEM_TYPE_REGEX = /^(-----BEGIN (.*)-----)/m;
function identifyPemType(rawKey) {
    if (rawKey instanceof Buffer) {
        rawKey = rawKey.toString("utf8");
    }
    var match = PEM_TYPE_REGEX.exec(rawKey);
    return !match ? undefined : match[2];
}
exports.identifyPemType = identifyPemType;
function removeTrailingLF(str) {
    var tmp = str.replace(/(\r|\n)+$/m, "").replace(/\r\n/gm, "\n");
    return tmp;
}
exports.removeTrailingLF = removeTrailingLF;
function toPem(raw_key, pem) {
    (0, assert_1.default)(raw_key, "expecting a key");
    (0, assert_1.default)(typeof pem === "string");
    var pemType = identifyPemType(raw_key);
    if (pemType) {
        return raw_key instanceof Buffer ? removeTrailingLF(raw_key.toString("utf8")) : removeTrailingLF(raw_key);
    }
    else {
        pemType = pem;
        (0, assert_1.default)(["CERTIFICATE REQUEST", "CERTIFICATE", "RSA PRIVATE KEY", "PUBLIC KEY", "X509 CRL"].indexOf(pemType) >= 0);
        var b = raw_key.toString("base64");
        var str = "-----BEGIN " + pemType + "-----\n";
        while (b.length) {
            str += b.substring(0, 64) + "\n";
            b = b.substring(64);
        }
        str += "-----END " + pemType + "-----";
        return str;
    }
}
exports.toPem = toPem;
function convertPEMtoDER(raw_key) {
    var match;
    var pemType;
    var base64str;
    var parts = [];
    PEM_REGEX.lastIndex = 0;
    while ((match = PEM_REGEX.exec(raw_key)) !== null) {
        pemType = match[2];
        base64str = match[3];
        base64str = base64str.replace(/\r?\n/g, "");
        parts.push(Buffer.from(base64str, "base64"));
    }
    return (0, crypto_explore_certificate_js_1.combine_der)(parts);
}
exports.convertPEMtoDER = convertPEMtoDER;
function hexDump(buffer, width) {
    if (!buffer) {
        return "<>";
    }
    width = width || 32;
    if (buffer.length > 1024) {
        return hexy(buffer.subarray(0, 1024), { width: width, format: "twos" }) + "\n .... ( " + buffer.length + ")";
    }
    else {
        return hexy(buffer, { width: width, format: "twos" });
    }
}
exports.hexDump = hexDump;
function makeMessageChunkSignature(chunk, options) {
    var signer = (0, crypto_1.createSign)(options.algorithm);
    signer.update(chunk);
    var signature = signer.sign(options.privateKey.hidden);
    (0, assert_1.default)(!options.signatureLength || signature.length === options.signatureLength);
    return signature;
}
exports.makeMessageChunkSignature = makeMessageChunkSignature;
function verifyMessageChunkSignature(blockToVerify, signature, options) {
    var verify = (0, crypto_1.createVerify)(options.algorithm);
    verify.update(blockToVerify);
    return verify.verify(options.publicKey, signature);
}
exports.verifyMessageChunkSignature = verifyMessageChunkSignature;
function makeSHA1Thumbprint(buffer) {
    return (0, crypto_1.createHash)("sha1").update(buffer).digest();
}
exports.makeSHA1Thumbprint = makeSHA1Thumbprint;
exports.RSA_PKCS1_OAEP_PADDING = constants_1.default.RSA_PKCS1_OAEP_PADDING;
exports.RSA_PKCS1_PADDING = constants_1.default.RSA_PKCS1_PADDING;
var PaddingAlgorithm;
(function (PaddingAlgorithm) {
    PaddingAlgorithm[PaddingAlgorithm["RSA_PKCS1_OAEP_PADDING"] = 4] = "RSA_PKCS1_OAEP_PADDING";
    PaddingAlgorithm[PaddingAlgorithm["RSA_PKCS1_PADDING"] = 1] = "RSA_PKCS1_PADDING";
})(PaddingAlgorithm || (exports.PaddingAlgorithm = PaddingAlgorithm = {}));
(0, assert_1.default)(PaddingAlgorithm.RSA_PKCS1_OAEP_PADDING === constants_1.default.RSA_PKCS1_OAEP_PADDING);
(0, assert_1.default)(PaddingAlgorithm.RSA_PKCS1_PADDING === constants_1.default.RSA_PKCS1_PADDING);
function publicEncrypt_native(buffer, publicKey, algorithm) {
    if (algorithm === undefined) {
        algorithm = PaddingAlgorithm.RSA_PKCS1_PADDING;
    }
    return (0, crypto_1.publicEncrypt)({
        key: publicKey,
        padding: algorithm,
    }, buffer);
}
exports.publicEncrypt_native = publicEncrypt_native;
function privateDecrypt_native(buffer, privateKey, algorithm) {
    if (algorithm === undefined) {
        algorithm = PaddingAlgorithm.RSA_PKCS1_PADDING;
    }
    try {
        return (0, crypto_1.privateDecrypt)({
            key: privateKey.hidden,
            padding: algorithm,
        }, buffer);
    }
    catch (err) {
        return Buffer.alloc(1);
    }
}
exports.privateDecrypt_native = privateDecrypt_native;
exports.publicEncrypt = publicEncrypt_native;
exports.privateDecrypt = privateDecrypt_native;
function publicEncrypt_long(buffer, publicKey, blockSize, padding, paddingAlgorithm) {
    if (paddingAlgorithm === undefined) {
        paddingAlgorithm = PaddingAlgorithm.RSA_PKCS1_PADDING;
    }
    if (paddingAlgorithm !== exports.RSA_PKCS1_PADDING && paddingAlgorithm !== exports.RSA_PKCS1_OAEP_PADDING) {
        throw new Error("Invalid padding algorithm " + paddingAlgorithm);
    }
    var chunk_size = blockSize - padding;
    var nbBlocks = Math.ceil(buffer.length / chunk_size);
    var outputBuffer = (0, buffer_utils_js_1.createFastUninitializedBuffer)(nbBlocks * blockSize);
    for (var i = 0; i < nbBlocks; i++) {
        var currentBlock = buffer.subarray(chunk_size * i, chunk_size * (i + 1));
        var encrypted_chunk = (0, exports.publicEncrypt)(currentBlock, publicKey, paddingAlgorithm);
        if (encrypted_chunk.length !== blockSize) {
            throw new Error("publicEncrypt_long unexpected chunk length ".concat(encrypted_chunk.length, "  expecting ").concat(blockSize));
        }
        encrypted_chunk.copy(outputBuffer, i * blockSize);
    }
    return outputBuffer;
}
exports.publicEncrypt_long = publicEncrypt_long;
function privateDecrypt_long(buffer, privateKey, blockSize, paddingAlgorithm) {
    paddingAlgorithm = paddingAlgorithm || exports.RSA_PKCS1_PADDING;
    if (paddingAlgorithm !== exports.RSA_PKCS1_PADDING && paddingAlgorithm !== exports.RSA_PKCS1_OAEP_PADDING) {
        throw new Error("Invalid padding algorithm " + paddingAlgorithm);
    }
    var nbBlocks = Math.ceil(buffer.length / blockSize);
    var outputBuffer = (0, buffer_utils_js_1.createFastUninitializedBuffer)(nbBlocks * blockSize);
    var total_length = 0;
    for (var i = 0; i < nbBlocks; i++) {
        var currentBlock = buffer.subarray(blockSize * i, Math.min(blockSize * (i + 1), buffer.length));
        var decrypted_buf = (0, exports.privateDecrypt)(currentBlock, privateKey, paddingAlgorithm);
        decrypted_buf.copy(outputBuffer, total_length);
        total_length += decrypted_buf.length;
    }
    return outputBuffer.subarray(0, total_length);
}
exports.privateDecrypt_long = privateDecrypt_long;
function coerceCertificatePem(certificate) {
    if (certificate instanceof Buffer) {
        certificate = toPem(certificate, "CERTIFICATE");
    }
    (0, assert_1.default)(typeof certificate === "string");
    return certificate;
}
exports.coerceCertificatePem = coerceCertificatePem;
function extractPublicKeyFromCertificateSync(certificate) {
    certificate = coerceCertificatePem(certificate);
    var key = jsrsasign.KEYUTIL.getKey(certificate);
    var publicKeyAsPem = jsrsasign.KEYUTIL.getPEM(key);
    (0, assert_1.default)(typeof publicKeyAsPem === "string");
    return publicKeyAsPem;
}
exports.extractPublicKeyFromCertificateSync = extractPublicKeyFromCertificateSync;
function extractPublicKeyFromCertificate(certificate, callback) {
    var err1 = null;
    var keyPem;
    try {
        keyPem = extractPublicKeyFromCertificateSync(certificate);
    }
    catch (err) {
        err1 = err;
    }
    setImmediate(function () {
        callback(err1, keyPem);
    });
}
exports.extractPublicKeyFromCertificate = extractPublicKeyFromCertificate;
//# sourceMappingURL=crypto_utils.js.map