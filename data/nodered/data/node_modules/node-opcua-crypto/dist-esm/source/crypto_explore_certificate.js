import assert from "assert";
import { _readBitString, TagType, readTag, _getBlock, _readStruct, formatBuffer2DigitHexWithColum, _readOctetString, _readListOfInteger, _readObjectIdentifier, _readAlgorithmIdentifier, _readECCAlgorithmIdentifier, _readBooleanValue, _readIntegerValue, _readLongIntegerValue, _readVersionValue, _readSignatureValue, _readValue, _readTime, _findBlockAtIndex, _readDirectoryName, } from "./asn1.js";
import { makeSHA1Thumbprint } from "./crypto_utils.js";
var doDebug = false;
function _readAttributeTypeAndValue(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    inner_blocks = _readStruct(buffer, inner_blocks[0]);
    var data = {
        identifier: _readObjectIdentifier(buffer, inner_blocks[0]).name,
        value: _readValue(buffer, inner_blocks[1]),
    };
    var result = {};
    for (var _i = 0, _a = Object.entries(data); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        result[key] = value;
    }
    return result;
}
function _readRelativeDistinguishedName(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    var data = inner_blocks.map(function (block) { return _readAttributeTypeAndValue(buffer, block); });
    var result = {};
    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
        var e = data_1[_i];
        result[e.identifier] = e.value;
    }
    return result;
}
function _readName(buffer, block) {
    return _readRelativeDistinguishedName(buffer, block);
}
function _readValidity(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    return {
        notBefore: _readTime(buffer, inner_blocks[0]),
        notAfter: _readTime(buffer, inner_blocks[1]),
    };
}
function _readAuthorityKeyIdentifier(buffer) {
    var block_info = readTag(buffer, 0);
    var blocks = _readStruct(buffer, block_info);
    var keyIdentifier_block = _findBlockAtIndex(blocks, 0);
    var authorityCertIssuer_block = _findBlockAtIndex(blocks, 1);
    var authorityCertSerialNumber_block = _findBlockAtIndex(blocks, 2);
    function _readAuthorityCertIssuer(block) {
        var inner_blocks = _readStruct(buffer, block);
        var directoryName_block = _findBlockAtIndex(inner_blocks, 4);
        if (directoryName_block) {
            var a = _readStruct(buffer, directoryName_block);
            return _readDirectoryName(buffer, a[0]);
        }
        else {
            throw new Error("Invalid _readAuthorityCertIssuer");
        }
    }
    function _readAuthorityCertIssuerFingerPrint(block) {
        var inner_blocks = _readStruct(buffer, block);
        var directoryName_block = _findBlockAtIndex(inner_blocks, 4);
        if (!directoryName_block) {
            return "";
        }
        var a = _readStruct(buffer, directoryName_block);
        if (a.length < 1) {
            return "";
        }
        return directoryName_block ? formatBuffer2DigitHexWithColum(makeSHA1Thumbprint(_getBlock(buffer, a[0]))) : "";
    }
    var authorityCertIssuer = authorityCertIssuer_block ? _readAuthorityCertIssuer(authorityCertIssuer_block) : null;
    var authorityCertIssuerFingerPrint = authorityCertIssuer_block
        ? _readAuthorityCertIssuerFingerPrint(authorityCertIssuer_block)
        : "";
    return {
        authorityCertIssuer: authorityCertIssuer,
        authorityCertIssuerFingerPrint: authorityCertIssuerFingerPrint,
        serial: authorityCertSerialNumber_block
            ? formatBuffer2DigitHexWithColum(_getBlock(buffer, authorityCertSerialNumber_block))
            : null,
        keyIdentifier: keyIdentifier_block ? formatBuffer2DigitHexWithColum(_getBlock(buffer, keyIdentifier_block)) : null,
    };
}
function readBasicConstraint2_5_29_19(buffer, block) {
    var block_info = readTag(buffer, 0);
    var inner_blocks = _readStruct(buffer, block_info);
    var cA = inner_blocks.length > 0 ? _readBooleanValue(buffer, inner_blocks[0]) : false;
    var pathLengthConstraint = 0;
    if (inner_blocks.length > 1) {
        pathLengthConstraint = _readIntegerValue(buffer, inner_blocks[1]);
    }
    return { critical: true, cA: cA, pathLengthConstraint: pathLengthConstraint };
}
function _readGeneralNames(buffer, block) {
    var _data = {
        1: { name: "rfc822Name", type: "IA5String" },
        2: { name: "dNSName", type: "IA5String" },
        3: { name: "x400Address", type: "ORAddress" },
        4: { name: "directoryName", type: "Name" },
        5: { name: "ediPartyName", type: "EDIPartyName" },
        6: { name: "uniformResourceIdentifier", type: "IA5String" },
        7: { name: "iPAddress", type: "OCTET_STRING" },
        8: { name: "registeredID", type: "OBJECT_IDENTIFIER" },
    };
    var blocks = _readStruct(buffer, block);
    function _readFromType(buffer, block, type) {
        switch (type) {
            case "IA5String":
                return buffer.subarray(block.position, block.position + block.length).toString("ascii");
            default:
                return buffer.subarray(block.position, block.position + block.length).toString("hex");
        }
    }
    var n = {};
    for (var _i = 0, blocks_1 = blocks; _i < blocks_1.length; _i++) {
        var block_1 = blocks_1[_i];
        assert((block_1.tag & 0x80) === 0x80);
        var t = block_1.tag & 0x7f;
        var type = _data[t];
        if (!type) {
            throw new Error(" INVALID TYPE => " + t + "0x" + t.toString(16));
        }
        n[type.name] = n[type.name] || [];
        n[type.name].push(_readFromType(buffer, block_1, type.type));
    }
    return n;
}
function _readSubjectAltNames(buffer) {
    var block_info = readTag(buffer, 0);
    return _readGeneralNames(buffer, block_info);
}
function readKeyUsage(oid, buffer) {
    var block_info = readTag(buffer, 0);
    var b2 = 0x00;
    var b3 = 0x00;
    if (block_info.length > 1) {
        b2 = buffer[block_info.position + 1];
        b3 = block_info.length > 2 ? buffer[block_info.position + 2] : 0;
    }
    return {
        digitalSignature: (b2 & 0x80) === 0x80,
        nonRepudiation: (b2 & 0x40) === 0x40,
        keyEncipherment: (b2 & 0x20) === 0x20,
        dataEncipherment: (b2 & 0x10) === 0x10,
        keyAgreement: (b2 & 0x08) === 0x08,
        keyCertSign: (b2 & 0x04) === 0x04,
        cRLSign: (b2 & 0x02) === 0x02,
        encipherOnly: (b2 & 0x01) === 0x01,
        decipherOnly: (b3 & 0x80) === 0x80,
    };
}
function readExtKeyUsage(oid, buffer) {
    assert(oid === "2.5.29.37");
    var block_info = readTag(buffer, 0);
    var inner_blocks = _readStruct(buffer, block_info);
    var extKeyUsage = {
        serverAuth: false,
        clientAuth: false,
        codeSigning: false,
        emailProtection: false,
        timeStamping: false,
        ipsecEndSystem: false,
        ipsecTunnel: false,
        ipsecUser: false,
        ocspSigning: false,
    };
    for (var _i = 0, inner_blocks_1 = inner_blocks; _i < inner_blocks_1.length; _i++) {
        var block = inner_blocks_1[_i];
        var identifier = _readObjectIdentifier(buffer, block);
        extKeyUsage[identifier.name] = true;
    }
    return extKeyUsage;
}
function _readSubjectPublicKey(buffer) {
    var block_info = readTag(buffer, 0);
    var blocks = _readStruct(buffer, block_info);
    return {
        modulus: buffer.subarray(blocks[0].position + 1, blocks[0].position + blocks[0].length),
    };
}
export function _readExtension(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    if (inner_blocks.length === 3) {
        assert(inner_blocks[1].tag === TagType.BOOLEAN);
        inner_blocks[1] = inner_blocks[2];
    }
    var identifier = _readObjectIdentifier(buffer, inner_blocks[0]);
    var buf = _getBlock(buffer, inner_blocks[1]);
    var value = null;
    switch (identifier.name) {
        case "subjectKeyIdentifier":
            value = formatBuffer2DigitHexWithColum(_readOctetString(buffer, inner_blocks[1]));
            break;
        case "subjectAltName":
            value = _readSubjectAltNames(buf);
            break;
        case "authorityKeyIdentifier":
            value = _readAuthorityKeyIdentifier(buf);
            break;
        case "basicConstraints":
            value = readBasicConstraint2_5_29_19(buf, inner_blocks[1]);
            break;
        case "certExtension":
            value = "basicConstraints ( not implemented yet) " + buf.toString("hex");
            break;
        case "extKeyUsage":
            value = readExtKeyUsage(identifier.oid, buf);
            break;
        case "keyUsage":
            value = readKeyUsage(identifier.oid, buf);
            break;
        default:
            value = "Unknown " + identifier.name + buf.toString("hex");
    }
    return {
        identifier: identifier,
        value: value,
    };
}
function _readExtensions(buffer, block) {
    assert(block.tag === 0xa3);
    var inner_blocks = _readStruct(buffer, block);
    inner_blocks = _readStruct(buffer, inner_blocks[0]);
    var extensions = inner_blocks.map(function (block) { return _readExtension(buffer, block); });
    var result = {};
    for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
        var e = extensions_1[_i];
        result[e.identifier.name] = e.value;
    }
    return result;
}
function _readSubjectPublicKeyInfo(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    var algorithm = _readAlgorithmIdentifier(buffer, inner_blocks[0]);
    var subjectPublicKey = _readBitString(buffer, inner_blocks[1]);
    var data = subjectPublicKey.data;
    var values = _readListOfInteger(data);
    return {
        algorithm: algorithm.identifier,
        keyLength: (values[0].length - 1),
        subjectPublicKey: _readSubjectPublicKey(subjectPublicKey.data),
    };
}
function _readSubjectECCPublicKeyInfo(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    var algorithm = _readECCAlgorithmIdentifier(buffer, inner_blocks[0]);
    var subjectPublicKey = _readBitString(buffer, inner_blocks[1]);
    var data = subjectPublicKey.data;
    return {
        algorithm: algorithm.identifier,
        keyLength: (data.length - 1),
        subjectPublicKey: {
            modulus: data,
        },
    };
}
export function readTbsCertificate(buffer, block) {
    var blocks = _readStruct(buffer, block);
    var version, serialNumber, signature, issuer, validity, subject, subjectFingerPrint, extensions;
    var subjectPublicKeyInfo;
    if (blocks.length === 6) {
        version = 1;
        serialNumber = formatBuffer2DigitHexWithColum(_readLongIntegerValue(buffer, blocks[0]));
        signature = _readAlgorithmIdentifier(buffer, blocks[1]);
        issuer = _readName(buffer, blocks[2]);
        validity = _readValidity(buffer, blocks[3]);
        subject = _readName(buffer, blocks[4]);
        subjectFingerPrint = formatBuffer2DigitHexWithColum(makeSHA1Thumbprint(_getBlock(buffer, blocks[4])));
        subjectPublicKeyInfo = _readSubjectPublicKeyInfo(buffer, blocks[5]);
        extensions = null;
    }
    else {
        var version_block = _findBlockAtIndex(blocks, 0);
        if (!version_block) {
            throw new Error("cannot find version block");
        }
        version = _readVersionValue(buffer, version_block) + 1;
        serialNumber = formatBuffer2DigitHexWithColum(_readLongIntegerValue(buffer, blocks[1]));
        signature = _readAlgorithmIdentifier(buffer, blocks[2]);
        issuer = _readName(buffer, blocks[3]);
        validity = _readValidity(buffer, blocks[4]);
        subject = _readName(buffer, blocks[5]);
        subjectFingerPrint = formatBuffer2DigitHexWithColum(makeSHA1Thumbprint(_getBlock(buffer, blocks[5])));
        var inner_block = _readStruct(buffer, blocks[6]);
        var what_type = _readAlgorithmIdentifier(buffer, inner_block[0]).identifier;
        switch (what_type) {
            case "rsaEncryption": {
                subjectPublicKeyInfo = _readSubjectPublicKeyInfo(buffer, blocks[6]);
                break;
            }
            case "ecPublicKey":
            default: {
                subjectPublicKeyInfo = _readSubjectECCPublicKeyInfo(buffer, blocks[6]);
                break;
            }
        }
        var extensionBlock = _findBlockAtIndex(blocks, 3);
        if (!extensionBlock) {
            doDebug && console.log("X509 certificate is invalid : cannot find extension block version =" + version_block);
            extensions = null;
        }
        else {
            extensions = _readExtensions(buffer, extensionBlock);
        }
    }
    return {
        version: version,
        serialNumber: serialNumber,
        signature: signature,
        issuer: issuer,
        validity: validity,
        subject: subject,
        subjectFingerPrint: subjectFingerPrint,
        subjectPublicKeyInfo: subjectPublicKeyInfo,
        extensions: extensions,
    };
}
export function exploreCertificate(certificate) {
    assert(certificate instanceof Buffer);
    if (!certificate._exploreCertificate_cache) {
        var block_info = readTag(certificate, 0);
        var blocks = _readStruct(certificate, block_info);
        certificate._exploreCertificate_cache = {
            tbsCertificate: readTbsCertificate(certificate, blocks[0]),
            signatureAlgorithm: _readAlgorithmIdentifier(certificate, blocks[1]),
            signatureValue: _readSignatureValue(certificate, blocks[2]),
        };
    }
    return certificate._exploreCertificate_cache;
}
export function split_der(certificateChain) {
    var certificate_chain = [];
    do {
        var block_info = readTag(certificateChain, 0);
        var length_1 = block_info.position + block_info.length;
        var der_certificate = certificateChain.subarray(0, length_1);
        certificate_chain.push(der_certificate);
        certificateChain = certificateChain.subarray(length_1);
    } while (certificateChain.length > 0);
    return certificate_chain;
}
export function combine_der(certificates) {
    var _loop_1 = function (cert) {
        var b = split_der(cert);
        var sum = 0;
        b.forEach(function (block) {
            var block_info = readTag(block, 0);
            assert(block_info.position + block_info.length === block.length);
            sum += block.length;
        });
        assert(sum === cert.length);
    };
    for (var _i = 0, certificates_1 = certificates; _i < certificates_1.length; _i++) {
        var cert = certificates_1[_i];
        _loop_1(cert);
    }
    return Buffer.concat(certificates);
}
//# sourceMappingURL=crypto_explore_certificate.js.map