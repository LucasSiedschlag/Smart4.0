import assert from "assert";
import { createCipheriv, createDecipheriv, createHmac } from "crypto";
import { createFastUninitializedBuffer } from "./buffer_utils.js";
import { verifyMessageChunkSignature } from "./crypto_utils.js";
import { exploreCertificateInfo } from "./explore_certificate.js";
function HMAC_HASH(sha1or256, secret, message) {
    return createHmac(sha1or256, secret).update(message).digest();
}
function plus(buf1, buf2) {
    return Buffer.concat([buf1, buf2]);
}
export function makePseudoRandomBuffer(secret, seed, minLength, sha1or256) {
    assert(seed instanceof Buffer);
    assert(sha1or256 === "SHA1" || sha1or256 === "SHA256");
    var a = [];
    a[0] = seed;
    var index = 1;
    var p_hash = createFastUninitializedBuffer(0);
    while (p_hash.length <= minLength) {
        a[index] = HMAC_HASH(sha1or256, secret, a[index - 1]);
        p_hash = plus(p_hash, HMAC_HASH(sha1or256, secret, plus(a[index], seed)));
        index += 1;
    }
    return p_hash.subarray(0, minLength);
}
export function computeDerivedKeys(secret, seed, options) {
    assert(Number.isFinite(options.signatureLength));
    assert(Number.isFinite(options.encryptingKeyLength));
    assert(Number.isFinite(options.encryptingBlockSize));
    assert(typeof options.algorithm === "string");
    options.sha1or256 = options.sha1or256 || "SHA1";
    assert(typeof options.sha1or256 === "string");
    var offset1 = options.signingKeyLength;
    var offset2 = offset1 + options.encryptingKeyLength;
    var minLength = offset2 + options.encryptingBlockSize;
    var buf = makePseudoRandomBuffer(secret, seed, minLength, options.sha1or256);
    return {
        signatureLength: options.signatureLength,
        signingKeyLength: options.signingKeyLength,
        encryptingKeyLength: options.encryptingKeyLength,
        encryptingBlockSize: options.encryptingBlockSize,
        algorithm: options.algorithm,
        sha1or256: options.sha1or256,
        signingKey: buf.subarray(0, offset1),
        encryptingKey: buf.subarray(offset1, offset2),
        initializationVector: buf.subarray(offset2, minLength),
    };
}
export function reduceLength(buffer, byteToRemove) {
    return buffer.subarray(0, buffer.length - byteToRemove);
}
export function removePadding(buffer) {
    var nbPaddingBytes = buffer.readUInt8(buffer.length - 1) + 1;
    return reduceLength(buffer, nbPaddingBytes);
}
export function verifyChunkSignature(chunk, options) {
    assert(chunk instanceof Buffer);
    var signatureLength = options.signatureLength || 0;
    if (signatureLength === 0) {
        var cert = exploreCertificateInfo(options.publicKey);
        signatureLength = cert.publicKeyLength || 0;
    }
    var block_to_verify = chunk.subarray(0, chunk.length - signatureLength);
    var signature = chunk.subarray(chunk.length - signatureLength);
    return verifyMessageChunkSignature(block_to_verify, signature, options);
}
export function computePaddingFooter(buffer, derivedKeys) {
    assert(Object.prototype.hasOwnProperty.call(derivedKeys, "encryptingBlockSize"));
    var paddingSize = derivedKeys.encryptingBlockSize - ((buffer.length + 1) % derivedKeys.encryptingBlockSize);
    var padding = createFastUninitializedBuffer(paddingSize + 1);
    padding.fill(paddingSize);
    return padding;
}
function derivedKeys_algorithm(derivedKeys) {
    assert(Object.prototype.hasOwnProperty.call(derivedKeys, "algorithm"));
    var algorithm = derivedKeys.algorithm || "aes-128-cbc";
    assert(algorithm === "aes-128-cbc" || algorithm === "aes-256-cbc");
    return algorithm;
}
export function encryptBufferWithDerivedKeys(buffer, derivedKeys) {
    var algorithm = derivedKeys_algorithm(derivedKeys);
    var key = derivedKeys.encryptingKey;
    var initVector = derivedKeys.initializationVector;
    var cipher = createCipheriv(algorithm, key, initVector);
    cipher.setAutoPadding(false);
    var encrypted_chunks = [];
    encrypted_chunks.push(cipher.update(buffer));
    encrypted_chunks.push(cipher.final());
    return Buffer.concat(encrypted_chunks);
}
export function decryptBufferWithDerivedKeys(buffer, derivedKeys) {
    var algorithm = derivedKeys_algorithm(derivedKeys);
    var key = derivedKeys.encryptingKey;
    var initVector = derivedKeys.initializationVector;
    var cipher = createDecipheriv(algorithm, key, initVector);
    cipher.setAutoPadding(false);
    var decrypted_chunks = [];
    decrypted_chunks.push(cipher.update(buffer));
    decrypted_chunks.push(cipher.final());
    return Buffer.concat(decrypted_chunks);
}
export function makeMessageChunkSignatureWithDerivedKeys(message, derivedKeys) {
    assert(message instanceof Buffer);
    assert(derivedKeys.signingKey instanceof Buffer);
    assert(typeof derivedKeys.sha1or256 === "string");
    assert(derivedKeys.sha1or256 === "SHA1" || derivedKeys.sha1or256 === "SHA256");
    var signature = createHmac(derivedKeys.sha1or256, derivedKeys.signingKey).update(message).digest();
    assert(signature.length === derivedKeys.signatureLength);
    return signature;
}
export function verifyChunkSignatureWithDerivedKeys(chunk, derivedKeys) {
    var message = chunk.subarray(0, chunk.length - derivedKeys.signatureLength);
    var expectedSignature = chunk.subarray(chunk.length - derivedKeys.signatureLength);
    var computedSignature = makeMessageChunkSignatureWithDerivedKeys(message, derivedKeys);
    return computedSignature.toString("hex") === expectedSignature.toString("hex");
}
//# sourceMappingURL=derived_keys.js.map