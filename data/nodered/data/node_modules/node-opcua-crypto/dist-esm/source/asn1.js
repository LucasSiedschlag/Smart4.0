import assert from "assert";
import { oid_map } from "./oid_map.js";
export var TagType;
(function (TagType) {
    TagType[TagType["BOOLEAN"] = 1] = "BOOLEAN";
    TagType[TagType["INTEGER"] = 2] = "INTEGER";
    TagType[TagType["BIT_STRING"] = 3] = "BIT_STRING";
    TagType[TagType["OCTET_STRING"] = 4] = "OCTET_STRING";
    TagType[TagType["NULL"] = 5] = "NULL";
    TagType[TagType["OBJECT_IDENTIFIER"] = 6] = "OBJECT_IDENTIFIER";
    TagType[TagType["UTF8String"] = 12] = "UTF8String";
    TagType[TagType["NumericString"] = 18] = "NumericString";
    TagType[TagType["PrintableString"] = 19] = "PrintableString";
    TagType[TagType["TeletexString"] = 20] = "TeletexString";
    TagType[TagType["IA5String"] = 22] = "IA5String";
    TagType[TagType["UTCTime"] = 23] = "UTCTime";
    TagType[TagType["GeneralizedTime"] = 24] = "GeneralizedTime";
    TagType[TagType["GraphicString"] = 25] = "GraphicString";
    TagType[TagType["VisibleString"] = 26] = "VisibleString";
    TagType[TagType["GeneralString"] = 27] = "GeneralString";
    TagType[TagType["UniversalString"] = 28] = "UniversalString";
    TagType[TagType["BMPString"] = 30] = "BMPString";
    TagType[TagType["SEQUENCE"] = 48] = "SEQUENCE";
    TagType[TagType["SET"] = 49] = "SET";
    TagType[TagType["A3"] = 163] = "A3";
})(TagType || (TagType = {}));
export function readTag(buf, pos) {
    assert(buf instanceof Buffer);
    assert(Number.isFinite(pos) && pos >= 0);
    if (buf.length <= pos) {
        throw new Error("Invalid position : buf.length=" + buf.length + " pos =" + pos);
    }
    var tag = buf.readUInt8(pos);
    pos += 1;
    var length = buf.readUInt8(pos);
    pos += 1;
    if (length > 127) {
        var nbBytes = length & 0x7f;
        length = 0;
        for (var i = 0; i < nbBytes; i++) {
            length = length * 256 + buf.readUInt8(pos);
            pos += 1;
        }
    }
    return { tag: tag, position: pos, length: length };
}
export function _readStruct(buf, blockInfo) {
    var length = blockInfo.length;
    var cursor = blockInfo.position;
    var end = blockInfo.position + length;
    var blocks = [];
    while (cursor < end) {
        var inner = readTag(buf, cursor);
        cursor = inner.position + inner.length;
        blocks.push(inner);
    }
    return blocks;
}
export function parseBitString(buffer, start, end, maxLength) {
    var unusedBit = buffer.readUInt8(start), lenBit = ((end - start - 1) << 3) - unusedBit, intro = "(" + lenBit + " bit)\n";
    var s = "", skip = unusedBit;
    for (var i = end - 1; i > start; --i) {
        var b = buffer.readUInt8(i);
        for (var j = skip; j < 8; ++j) {
            s += (b >> j) & 1 ? "1" : "0";
        }
        skip = 0;
        assert(s.length <= maxLength);
    }
    return intro + s;
}
export function _readBitString(buffer, block) {
    assert(block.tag === TagType.BIT_STRING);
    var data = _getBlock(buffer, block);
    var ignore_bits = data.readUInt8(0);
    return {
        lengthInBits: data.length * 8 - ignore_bits,
        lengthInBytes: data.length - 1,
        data: data.subarray(1),
        debug: parseBitString(buffer, block.position, block.length + block.position, 4 * 16 * 1024),
    };
}
export function formatBuffer2DigitHexWithColum(buffer) {
    var value = [];
    for (var i = 0; i < buffer.length; i++) {
        value.push(("00" + buffer.readUInt8(i).toString(16)).substr(-2, 2));
    }
    return value
        .join(":")
        .toUpperCase()
        .replace(/^(00:)*/, "");
}
export function _readOctetString(buffer, block) {
    assert(block.tag === TagType.OCTET_STRING);
    var tag = readTag(buffer, block.position);
    assert(tag.tag === TagType.OCTET_STRING);
    var nbBytes = tag.length;
    var pos = tag.position;
    var b = buffer.subarray(pos, pos + nbBytes);
    return b;
}
export function _getBlock(buffer, block) {
    var start = block.position;
    var end = block.position + block.length;
    return buffer.subarray(start, end);
}
export function _readIntegerAsByteString(buffer, block) {
    return _getBlock(buffer, block);
}
export function _readListOfInteger(buffer) {
    var block = readTag(buffer, 0);
    var inner_blocks = _readStruct(buffer, block);
    return inner_blocks.map(function (bblock) {
        return _readIntegerAsByteString(buffer, bblock);
    });
}
function parseOID(buffer, start, end) {
    var s = "", n = 0, bits = 0;
    for (var i = start; i < end; ++i) {
        var v = buffer.readUInt8(i);
        n = n * 128 + (v & 0x7f);
        bits += 7;
        if (!(v & 0x80)) {
            if (s === "") {
                var m = n < 80 ? (n < 40 ? 0 : 1) : 2;
                s = m + "." + (n - m * 40);
            }
            else {
                s += "." + n.toString();
            }
            n = 0;
            bits = 0;
        }
    }
    assert(bits === 0);
    return s;
}
export function _readObjectIdentifier(buffer, block) {
    assert(block.tag === TagType.OBJECT_IDENTIFIER);
    var b = buffer.subarray(block.position, block.position + block.length);
    var oid = parseOID(b, 0, block.length);
    return {
        oid: oid,
        name: oid_map[oid] ? oid_map[oid].d : oid,
    };
}
export function _readAlgorithmIdentifier(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    return {
        identifier: _readObjectIdentifier(buffer, inner_blocks[0]).name,
    };
}
;
export function _readECCAlgorithmIdentifier(buffer, block) {
    var inner_blocks = _readStruct(buffer, block);
    return {
        identifier: _readObjectIdentifier(buffer, inner_blocks[1]).name,
    };
}
;
export function _readSignatureValueBin(buffer, block) {
    return _readBitString(buffer, block).data;
}
export function _readSignatureValue(buffer, block) {
    return _readSignatureValueBin(buffer, block).toString("hex");
}
export function _readLongIntegerValue(buffer, block) {
    assert(block.tag === TagType.INTEGER, "expecting a INTEGER tag");
    var pos = block.position;
    var nbBytes = block.length;
    var buf = buffer.subarray(pos, pos + nbBytes);
    return buf;
}
export function _readIntegerValue(buffer, block) {
    assert(block.tag === TagType.INTEGER, "expecting a INTEGER tag");
    var pos = block.position;
    var nbBytes = block.length;
    assert(nbBytes < 4);
    var value = 0;
    for (var i = 0; i < nbBytes; i++) {
        value = value * 256 + buffer.readUInt8(pos);
        pos += 1;
    }
    return value;
}
export function _readBooleanValue(buffer, block) {
    assert(block.tag === TagType.BOOLEAN, "expecting a BOOLEAN tag. got " + TagType[block.tag]);
    var pos = block.position;
    var nbBytes = block.length;
    assert(nbBytes < 4);
    var value = buffer.readUInt8(pos) ? true : false;
    return value;
}
export function _readVersionValue(buffer, block) {
    block = readTag(buffer, block.position);
    return _readIntegerValue(buffer, block);
}
function convertGeneralizedTime(str) {
    var year = parseInt(str.substr(0, 4), 10);
    var month = parseInt(str.substr(4, 2), 10) - 1;
    var day = parseInt(str.substr(6, 2), 10);
    var hours = parseInt(str.substr(8, 2), 10);
    var mins = parseInt(str.substr(10, 2), 10);
    var secs = parseInt(str.substr(12, 2), 10);
    return new Date(Date.UTC(year, month, day, hours, mins, secs));
}
function _readBMPString(buffer, block) {
    var strBuff = _getBlock(buffer, block);
    var str = "";
    for (var i = 0; i < strBuff.length; i += 2) {
        var word = strBuff.readUInt16BE(i);
        str += String.fromCharCode(word);
    }
    return str;
}
function convertUTCTime(str) {
    var year = parseInt(str.substr(0, 2), 10);
    var month = parseInt(str.substr(2, 2), 10) - 1;
    var day = parseInt(str.substr(4, 2), 10);
    var hours = parseInt(str.substr(6, 2), 10);
    var mins = parseInt(str.substr(8, 2), 10);
    var secs = parseInt(str.substr(10, 2), 10);
    year += year >= 50 ? 1900 : 2000;
    return new Date(Date.UTC(year, month, day, hours, mins, secs));
}
export function _readValue(buffer, block) {
    switch (block.tag) {
        case TagType.BOOLEAN:
            return _readBooleanValue(buffer, block);
        case TagType.BMPString:
            return _readBMPString(buffer, block);
        case TagType.PrintableString:
        case TagType.TeletexString:
        case TagType.UTF8String:
        case TagType.NumericString:
        case TagType.IA5String:
            return _getBlock(buffer, block).toString("ascii");
        case TagType.UTCTime:
            return convertUTCTime(_getBlock(buffer, block).toString("ascii"));
        case TagType.GeneralizedTime:
            return convertGeneralizedTime(_getBlock(buffer, block).toString("ascii"));
        default:
            throw new Error("Invalid tag 0x" + block.tag.toString(16) + "");
    }
}
export function compactDirectoryName(d) {
    return JSON.stringify(d);
}
export function _readDirectoryName(buffer, block) {
    var set_blocks = _readStruct(buffer, block);
    var names = {};
    for (var _i = 0, set_blocks_1 = set_blocks; _i < set_blocks_1.length; _i++) {
        var set_block = set_blocks_1[_i];
        assert(set_block.tag === 0x31);
        var blocks = _readStruct(buffer, set_block);
        assert(blocks.length === 1);
        assert(blocks[0].tag === 0x30);
        var sequenceBlock = _readStruct(buffer, blocks[0]);
        assert(sequenceBlock.length === 2);
        var type = _readObjectIdentifier(buffer, sequenceBlock[0]);
        names[type.name] = _readValue(buffer, sequenceBlock[1]);
    }
    return names;
}
export function _findBlockAtIndex(blocks, index) {
    var tmp = blocks.filter(function (b) { return b.tag === 0xa0 + index || b.tag === 0x80 + index; });
    if (tmp.length === 0) {
        return null;
    }
    return tmp[0];
}
export function _readTime(buffer, block) {
    return _readValue(buffer, block);
}
//# sourceMappingURL=asn1.js.map