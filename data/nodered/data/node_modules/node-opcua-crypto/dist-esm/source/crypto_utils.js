import constants from "constants";
import assert from "assert";
import { createHash, createSign, createVerify, publicEncrypt as publicEncrypt1, privateDecrypt as privateDecrypt1, } from "crypto";
var hexy = require("hexy").hexy;
import { createFastUninitializedBuffer } from "./buffer_utils.js";
import { combine_der } from "./crypto_explore_certificate.js";
var jsrsasign = require("jsrsasign");
var PEM_REGEX = /^(-----BEGIN (.*)-----\r?\n([/+=a-zA-Z0-9\r\n]*)\r?\n-----END \2-----\r?\n?)/gm;
var PEM_TYPE_REGEX = /^(-----BEGIN (.*)-----)/m;
export function identifyPemType(rawKey) {
    if (rawKey instanceof Buffer) {
        rawKey = rawKey.toString("utf8");
    }
    var match = PEM_TYPE_REGEX.exec(rawKey);
    return !match ? undefined : match[2];
}
export function removeTrailingLF(str) {
    var tmp = str.replace(/(\r|\n)+$/m, "").replace(/\r\n/gm, "\n");
    return tmp;
}
export function toPem(raw_key, pem) {
    assert(raw_key, "expecting a key");
    assert(typeof pem === "string");
    var pemType = identifyPemType(raw_key);
    if (pemType) {
        return raw_key instanceof Buffer ? removeTrailingLF(raw_key.toString("utf8")) : removeTrailingLF(raw_key);
    }
    else {
        pemType = pem;
        assert(["CERTIFICATE REQUEST", "CERTIFICATE", "RSA PRIVATE KEY", "PUBLIC KEY", "X509 CRL"].indexOf(pemType) >= 0);
        var b = raw_key.toString("base64");
        var str = "-----BEGIN " + pemType + "-----\n";
        while (b.length) {
            str += b.substring(0, 64) + "\n";
            b = b.substring(64);
        }
        str += "-----END " + pemType + "-----";
        return str;
    }
}
export function convertPEMtoDER(raw_key) {
    var match;
    var pemType;
    var base64str;
    var parts = [];
    PEM_REGEX.lastIndex = 0;
    while ((match = PEM_REGEX.exec(raw_key)) !== null) {
        pemType = match[2];
        base64str = match[3];
        base64str = base64str.replace(/\r?\n/g, "");
        parts.push(Buffer.from(base64str, "base64"));
    }
    return combine_der(parts);
}
export function hexDump(buffer, width) {
    if (!buffer) {
        return "<>";
    }
    width = width || 32;
    if (buffer.length > 1024) {
        return hexy(buffer.subarray(0, 1024), { width: width, format: "twos" }) + "\n .... ( " + buffer.length + ")";
    }
    else {
        return hexy(buffer, { width: width, format: "twos" });
    }
}
export function makeMessageChunkSignature(chunk, options) {
    var signer = createSign(options.algorithm);
    signer.update(chunk);
    var signature = signer.sign(options.privateKey.hidden);
    assert(!options.signatureLength || signature.length === options.signatureLength);
    return signature;
}
export function verifyMessageChunkSignature(blockToVerify, signature, options) {
    var verify = createVerify(options.algorithm);
    verify.update(blockToVerify);
    return verify.verify(options.publicKey, signature);
}
export function makeSHA1Thumbprint(buffer) {
    return createHash("sha1").update(buffer).digest();
}
export var RSA_PKCS1_OAEP_PADDING = constants.RSA_PKCS1_OAEP_PADDING;
export var RSA_PKCS1_PADDING = constants.RSA_PKCS1_PADDING;
export var PaddingAlgorithm;
(function (PaddingAlgorithm) {
    PaddingAlgorithm[PaddingAlgorithm["RSA_PKCS1_OAEP_PADDING"] = 4] = "RSA_PKCS1_OAEP_PADDING";
    PaddingAlgorithm[PaddingAlgorithm["RSA_PKCS1_PADDING"] = 1] = "RSA_PKCS1_PADDING";
})(PaddingAlgorithm || (PaddingAlgorithm = {}));
assert(PaddingAlgorithm.RSA_PKCS1_OAEP_PADDING === constants.RSA_PKCS1_OAEP_PADDING);
assert(PaddingAlgorithm.RSA_PKCS1_PADDING === constants.RSA_PKCS1_PADDING);
export function publicEncrypt_native(buffer, publicKey, algorithm) {
    if (algorithm === undefined) {
        algorithm = PaddingAlgorithm.RSA_PKCS1_PADDING;
    }
    return publicEncrypt1({
        key: publicKey,
        padding: algorithm,
    }, buffer);
}
export function privateDecrypt_native(buffer, privateKey, algorithm) {
    if (algorithm === undefined) {
        algorithm = PaddingAlgorithm.RSA_PKCS1_PADDING;
    }
    try {
        return privateDecrypt1({
            key: privateKey.hidden,
            padding: algorithm,
        }, buffer);
    }
    catch (err) {
        return Buffer.alloc(1);
    }
}
export var publicEncrypt = publicEncrypt_native;
export var privateDecrypt = privateDecrypt_native;
export function publicEncrypt_long(buffer, publicKey, blockSize, padding, paddingAlgorithm) {
    if (paddingAlgorithm === undefined) {
        paddingAlgorithm = PaddingAlgorithm.RSA_PKCS1_PADDING;
    }
    if (paddingAlgorithm !== RSA_PKCS1_PADDING && paddingAlgorithm !== RSA_PKCS1_OAEP_PADDING) {
        throw new Error("Invalid padding algorithm " + paddingAlgorithm);
    }
    var chunk_size = blockSize - padding;
    var nbBlocks = Math.ceil(buffer.length / chunk_size);
    var outputBuffer = createFastUninitializedBuffer(nbBlocks * blockSize);
    for (var i = 0; i < nbBlocks; i++) {
        var currentBlock = buffer.subarray(chunk_size * i, chunk_size * (i + 1));
        var encrypted_chunk = publicEncrypt(currentBlock, publicKey, paddingAlgorithm);
        if (encrypted_chunk.length !== blockSize) {
            throw new Error("publicEncrypt_long unexpected chunk length ".concat(encrypted_chunk.length, "  expecting ").concat(blockSize));
        }
        encrypted_chunk.copy(outputBuffer, i * blockSize);
    }
    return outputBuffer;
}
export function privateDecrypt_long(buffer, privateKey, blockSize, paddingAlgorithm) {
    paddingAlgorithm = paddingAlgorithm || RSA_PKCS1_PADDING;
    if (paddingAlgorithm !== RSA_PKCS1_PADDING && paddingAlgorithm !== RSA_PKCS1_OAEP_PADDING) {
        throw new Error("Invalid padding algorithm " + paddingAlgorithm);
    }
    var nbBlocks = Math.ceil(buffer.length / blockSize);
    var outputBuffer = createFastUninitializedBuffer(nbBlocks * blockSize);
    var total_length = 0;
    for (var i = 0; i < nbBlocks; i++) {
        var currentBlock = buffer.subarray(blockSize * i, Math.min(blockSize * (i + 1), buffer.length));
        var decrypted_buf = privateDecrypt(currentBlock, privateKey, paddingAlgorithm);
        decrypted_buf.copy(outputBuffer, total_length);
        total_length += decrypted_buf.length;
    }
    return outputBuffer.subarray(0, total_length);
}
export function coerceCertificatePem(certificate) {
    if (certificate instanceof Buffer) {
        certificate = toPem(certificate, "CERTIFICATE");
    }
    assert(typeof certificate === "string");
    return certificate;
}
export function extractPublicKeyFromCertificateSync(certificate) {
    certificate = coerceCertificatePem(certificate);
    var key = jsrsasign.KEYUTIL.getKey(certificate);
    var publicKeyAsPem = jsrsasign.KEYUTIL.getPEM(key);
    assert(typeof publicKeyAsPem === "string");
    return publicKeyAsPem;
}
export function extractPublicKeyFromCertificate(certificate, callback) {
    var err1 = null;
    var keyPem;
    try {
        keyPem = extractPublicKeyFromCertificateSync(certificate);
    }
    catch (err) {
        err1 = err;
    }
    setImmediate(function () {
        callback(err1, keyPem);
    });
}
//# sourceMappingURL=crypto_utils.js.map